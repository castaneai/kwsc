//
// 配列操作を支援するモジュール
// 基本的に渡した配列そのものを書き換える”破壊メソッド”なので扱いに注意
//

//
// 単体テスト
//
ifb GET_UWSC_NAME = "Array.uws"
	call Test.uws
	
	// 指定した要素を含むかどうか判断できるかどうか
	dim a[] = 1, 2, 3
	Test.assert_equals(true, Array.contains(a, 1))
	
	// 要素を追加できるかどうか
	Array.append(a, 4)
	Test.assert_equals(4, a[3])
	
	// 配列をコピーできるか
	// たとえコピー先の配列がコピー元より小さくても自動的に拡張されるか
	dim src[] = 1, 2, 3
	dim dst[0]
	Array.copy(src, dst)
	Test.assert_equals(1, dst[0])
	Test.assert_equals(2, dst[1])
	Test.assert_equals(3, dst[2])
	// コピー元配列に要素を追加してもコピー先は変化しないかどうか
	src[0] = 4
	Test.assert_equals(1, dst[0])
	
	// 要素を削除できるかどうか
	dim b[] = 1, 1, 2, 2, 3, 3
	Array.remove(b, 2)
	Test.assert_equals(4, length(b))
	Test.assert_equals(false, Array.contains(b, 2))
	
	// 配列の要素による比較ができるかどうか
	dim c[] = 1, 2, 3
	dim d[] = 1, 2, 3
	Test.assert_equals(true, Array.sequential_equal(c, d))
	
	// 指定文字による分割ができるかどうか
	dim str = "A B C D"
	dim array[0]
	Array.split(array, str, " ")
	dim expected_array[] = "A", "B", "C", "D"
	Test.assert_equals(true, Array.sequential_equal(array, expected_array))
	
	// 通常の配列とSAFEARRAYでも要素比較可能かどうか
	dim e[] = 1,2,3,4
	dim f = safearray(0, 3)
	f[0] = 1
	f[1] = 2
	f[2] = 3
	f[3] = 4
	Test.assert_equals(true, Array.sequential_equal(e, f))
	
	// SAFEARRAYを通常の配列に変換できるか
	dim sa1 = safearray(0, 1)
	sa1[0] = 10
	sa1[1] = 20
	dim na1[2]
	Array.copy(sa1, na1)
	Test.assert_equals(10, na1[0])
	Test.assert_equals(20, na1[1])
endif

//
// モジュール本体
//
module Array

	//
	// 末尾に値を追加する
	//
	procedure append(var array[], value)
		dim new_index = resize(array, length(array))
		array[new_index] = value
	fend
	
	//
	// 配列をコピーする
	//
	procedure copy(src[], var dst[])
		ifb length(src) > length(dst)
			resize(dst, length(src) - 1)
		endif
		for i = 0 to length(src) - 1
			dst[i] = src[i]
		next
	fend
	
	//
	// 値が含まれているかどうか調べる
	// 線形探索アルゴリズムを使っているため巨大な配列に使うと非常に処理時間がかかるので注意
	//
	function contains(array[], value)
		for i = 0 to length(array) - 1
			ifb array[i] = value
				result = true
				exit
			endif
		next
		
		result = false
	fend
	
	//
	// 配列から指定した値を持つ要素を削除する
	// 同じ値を持つものが2つ以上あればそれらも全て削除する
	//
	function remove(var array[], value)
		dim remove_index = -1
		for i = 0 to length(array) - 1
			ifb array[i] = value
				remove_index = i
				break
			endif
		next
		ifb remove_index = -1
			result = -1
			exit
		endif
		// 削除した分左にシフトする
		for i = remove_index to length(array) - 2
			array[i] = array[i + 1]
		next
		resize(array, length(array) - 2)
		// 再帰的に適用
		result = remove(array, value)
	fend

	//
	// 2つの配列が等しいかどうか調べる
	// 2つの配列が等しいというのは要素数が同じで、
	// すべての要素が順序通り同じであるときのみ成り立つ
	//
	function sequential_equal(array1[], array2[])
		ifb length(array1) <> length(array2)
			result = false
			exit
		endif
		for i = 0 to length(array1) - 1
			ifb array1[i] <> array2[i]
				result = false
				exit
			endif
		next
		
		result = true
	fend

	//
	// 文字列を指定文字で区切って配列に格納する
	// 返り値は完成した配列の要素数
	// UWSC のver4.7からは標準関数となっている
	//
	function split(var array[], str, delimiter)
		str = trim(str)
		dim count = 0
		dim buffer = ""
		for i = 1 to lengthb(str)
			char = copyb(str, i, 1)
			ifb char = delimiter
				count = count + 1
				resize(array, count - 1)
				array[count - 1] = buffer
				buffer = ""
			else
				buffer = buffer + char
			endif
		next
		ifb length(buffer) > 0
			count = count + 1
			resize(array, count - 1)
			array[count - 1] = buffer
		endif
		
		result = count 
	fend

endmodule